redesign of code structure count : 1 (hopefully it won't get higher)

the actual graphs I'll use will be retrieved from OSM and pretreated in python with OSMnx 
  
 
also will have to do clean error reporting 

done : 
    - graphs are kinda implemented
        - I can add stuf to them 
        - I can print them (I can't load them from a file yet though)

        - I can also load them let's go 
    
    - script can load a city into a networkx graph thingy (easy part) 

    - walker structure pretty much done 

    - apparently I wrote a tactics structure I didn't even remember it 

    - rewrote the graph implem in the GraphTable structure 

    - wrote the table manip fn ; haven't tested them yet

    - graph table fully implmented 

    - deleted deprecated stuff

    - implemented some of the movement ; tested it 



holy shit I know how to make the movement related stuff ; I should have two stacks to store walkers 
in the walker table ; 

one stack is the stack at the beginning of a generation and is where the walkers currently are 
and the second one will be the "destination" of the walkers after the first iteration . 

this means that when i start a new simulation the current stack become the one of the next gen and 
the one of the next gen gets flushed 

when a walker moves from a node it goes in the stack for the next gen 
this means that I have insertion and deletion of a walker in O(1) and I maintain the search of 
it given a key in O(a) where a is the number of walkers in the stack

pending :  

    - figure out the way to implement movement : 
        - add iteration field to line arr and walkers; if don't match don't take into account 
        - add curflux / netflux field to line arr , at the start of iteration set curflux to nextflux 
          and reset nextflux 

    - make the pyhton script to retrieve / format / write real graphs from the real world
      (god have mercy on me) 

        - do a function to handle the whole discretisation of the graph w a custom step 
          (scary part)
        - then do a function to dump it in the custom csv format (less scary but prolly hard part)

    - once all of this is done I can actually start to simulate stuff 

    - write propper error reporting 

    - write the trace fn 

    - maybe make a "misc" file w the memory + error functions in it 

    - if I have the time use custom malloc 

make a choice for the movement of walkers in the table 
  -> append by ref of entry (know which index) 
  -> append by index of entry  (use the index)
I'll implement both and see which one is the best 

change format to retrieve curgen info of the simul

the rules should actually prolly return a line cuz it allows to update flux information fast 
so it's likely better to work w entry references n stuff in the code 

hollup is the flux the number of ppl going FROM a to b 
or the number of ppl that went in n out of a node a 
uh oh

./graph_treament.py 48.866 2.33 1000 10 /tmp/tmp